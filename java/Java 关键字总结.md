# Java 关键字 使用和总结

## final 关键字
**final关键字主要用在三个地方：变量、方法、类。**
1. 对于一个final变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。
2. 当用final修饰一个类时，表明这个类不能被继承。final类中的所有成员方法都会被隐式地指定为final方法。
3. 使用final方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的Java实现版本中，会将final方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升（现在的Java版本已经不需要使用final方法进行这些优化了）。类中所有的private方法都隐式地指定为final。

## finally 关键字
> finally关键字用来定义始终在try-catch-finally语句中执行的块。
> finally块通常包含清理代码，用在部分执行try块后恢复正常运行。

```
try {
// 可能引发异常的块
}
catch (<java.lang.Exception或子类> e) {
// 处理异常e的代码
}
finally {
// 有异常或无异常情况下都执行的语句
}
```

开始和结束标记 { 和 } 是finally子句语法的一部分，即使该子句只包含一个语句，也不能省略这两个标记。
每个try块都必须至少有一个catch或finally子句。
如果执行try块的任何部分，不论是否出现异常，也不论try或catch块是否包含return、continue或break语句，都一定会执行finally块中的代码。
如果不出现异常，控件将跳过try块，进入finally块。
如果在执行try块期间出现异常，并且相应的catch块包含break、continue或return语句，控件将首先穿过finally块，之后再执行break、continue或return。

## static 关键字
**static 关键字主要有以下四种使用场景：**

1. **修饰成员变量和成员方法:** 被 static 修饰的成员属于类，不属于单个这个类的某个对象，被类中所有对象共享，可以并且建议通过类名调用。被static 声明的成员变量属于静态成员变量，静态变量 存放在 Java 内存区域的方法区。调用格式：`类名.静态变量名`    `类名.静态方法名()`
2. **静态代码块:** 静态代码块定义在类中方法外, 静态代码块在非静态代码块之前执行(静态代码块—>非静态代码块—>构造方法)。 该类不管创建多少对象，静态代码块只执行一次.
3. **静态内部类（static修饰类的话只能修饰内部类）：** 静态内部类与非静态内部类之间存在一个最大的区别: 非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围类，但是静态内部类却没有。没有这个引用就意味着：1. 它的创建是不需要依赖外围类的创建。2. 它不能使用任何外围类的非static成员变量和方法。
4. **静态导包(用来导入类中的静态资源，1.5之后的新特性):** 格式为：`import static` 这两个关键字连用可以指定导入某个类中的指定静态资源，并且不需要使用类名调用类中静态成员，可以直接使用类中静态成员变量和成员方法。

## this 关键字
> 作用：this 代指当前类的实例，使用this可以调用当前类中的属性，方法和构造函数。 
1. 返回当前方法的对象的引用 
2. 访问当前类的当前实例的变量。调用当前类的当前实例的方法。
3. 当方法参数名和成员变量名相同时用于区分参数名和成员变量名
```
public void setAge(int age) {
    this.age = age;
}
```
“this.age”代表成员变量名，“age”代表参数名。

## super 关键字
> super关键字用于从子类访问父类的变量和方法。 

**使用 this 和 super 要注意的问题：**
- 在构造器中使用 `super（）` 调用父类中的其他构造方法时，该语句必须处于构造器的首行，否则编译器会报错。另外，this 调用本类中的其他构造方法时，也要放在首行。
- this、super不能用在static方法中。

**备注：**
被 static 修饰的成员属于类，不属于单个这个类的某个对象，被类中所有对象共享。而 this 代表对本类对象的引用，指向本类对象；而 super 代表对父类对象的引用，指向父类对象；所以， **this和super是属于对象范畴的东西，而静态方法是属于类范畴的东西**。

### synchronized 关键字
> 应用于方法或语句块，并为一次只应由一个线程执行的关键代码段提供保护。

synchronized关键字可防止代码的关键代码段一次被多个线程执行。
- 如果应用于静态方法，那么，当该方法一次由一个线程执行时，整个类将被锁定。
- 如果应用于实例方法，那么，当该方法一次由一个线程访问时，该实例将被锁定。
- 如果应用于对象或数组，当关联的代码块一次由一个线程执行时，对象或数组将被锁定。

### throw 关键字
> 用于引发异常。

throw语句将java.lang.Throwable作为参数。Throwable在调用栈中向上传播，直到被适当的catch块捕获。
引发非RuntimeException异常的任何方法还必须在方法声明中使用throws修饰符来声明它引发的异常。

### throws 关键字
> 应用于方法，以便指出方法引发了特定类型的异常。

throws关键字将逗号分隔的java.lang.Throwables列表作为参数。
引发非RuntimeException异常的任何方法还必须在方法声明中使用throws修饰符来声明它引发的异常。
要在try-catch块中包含带throws子句的方法的调用，必须提供该方法的调用者。

## transient 关键字
> 应用于类的成员变量，以便指出该成员变量不应在包含它的类实例已序列化时被序列化。

详情可见： # [Why does Java have transient fields?](https://stackoverflow.com/questions/910374/why-does-java-have-transient-fields)


## volatile 关键字
> 用于表示可以被多个线程异步修改的成员变量。为了确保所有线程所看到的指定变量的值都是相同的。

一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：
- 保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。
- 禁止进行指令重排序。

详情可见 ： # [Java并发编程：volatile关键字解析](https://www.cnblogs.com/dolphin0520/p/3920373.html)

## 备注：
### synchronized 关键字和 volatile 关键字的区别
- volatile关键字是线程同步的轻量级实现，所以volatile性能肯定比synchronized关键字要好。但是volatile关键字只能用于变量而synchronized关键字可以修饰方法以及代码块。synchronized关键字在JavaSE1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁以及其它各种优化之后执行效率有了显著提升，实际开发中使用 synchronized 关键字的场景还是更多一些。
- 多线程访问volatile关键字不会发生阻塞，而synchronized关键字可能会发生阻塞
- volatile关键字能保证数据的可见性，但不能保证数据的原子性。synchronized关键字两者都能保证。
- volatile关键字主要用于解决变量在多个线程之间的可见性，而 synchronized关键字解决的是多个线程之间访问资源的同步性。

## 参考： [https://github.com/Snailclimb/JavaGuide](https://github.com/Snailclimb/JavaGuide)
