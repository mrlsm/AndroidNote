# 设计模式 -- 备忘录模式

### 定义

在不破坏封闭的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样，以后就可将该对象恢复到原先保存的状态。

### 使用场景

- 需要保存一个对象在某一时刻的状态或部分状态。
- 如果用一个接口来让其他对象得到这些状态，将会暴露对象的实现细节并破坏对象的封装性，一个对象不希望外界直接访问其内部状态，通过中间对象可以间接访问其内部状态。

### UML 类图

![](https://github.com/mrlsm/Note/blob/master/designPatterns/images/memento_uml.jpg)

由上图，备忘录模式 主要包含这几种角色：

- **Originator**（发起人角色）：记录当前时刻的内部状态信息，提供创建备忘录和恢复备忘录数据的功能，实现其他业务功能，它可以访问备忘录里的所有信息。
- **Memento**（备忘录角色）：负责存储发起人的内部状态，在需要的时候提供这些内部状态给发起人。
- **Caretaker**（管理者角色）：对备忘录进行管理，提供保存与获取备忘录的功能，但其不能对备忘录的内容进行访问与修改。

### 优缺点
- 优点：
    - 提供了一种可以恢复状态的机制。当用户需要时能够比较方便地将数据恢复到某个历史的状态。
	- 实现了内部状态的封装。除了创建它的发起人之外，其他对象都不能够访问这些状态信息。
	- 简化了Originator类。发起人不需要管理和保存其内部状态的各个备份，所有状态信息都保存在备忘录中，并由管理者进行管理，这符合单一职责原则。
- 缺点：
    - 资源消耗大。如果要保存的内部状态信息过多或者特别频繁，将会占用比较大的内存资源。

### Android 源码中的备忘录模式的实现

##### Activity 的状态保存

当Activity不是正常方式退出，且Activity在随后的时间内被系统杀死之前会调用这两个方法让开发人员可以有机会存储Activity相关信息，且在下次返回Activity时恢复这些数据。通过这两个函数。开发人员能够在某些特殊场景下储存与界面相关的信息，提升用户体验。
